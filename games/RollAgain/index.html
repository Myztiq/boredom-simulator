
<!--
	Roll Again: Mini-Game for Boredom Simulator
	http://BoredomSimulator.com

	Copyright (c) 2015 Amber Roy
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Roll Again</title>

  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>

  <!-- from https://github.com/chandlerprall/Physijs -->
  <script src="physi.js"></script>

  <style>
    html, body { padding: 0; margin: 0; }
    body { width: 100%; height: 100%; }
  </style>

</head>
<body>

<script>

Physijs.scripts.worker = 'physijs_worker.js';
Physijs.scripts.ammo = 'ammo.js';

var renderer, scene, camera, controls;
var theDie;

function init() {

	renderer = new THREE.WebGLRenderer({ antialias: true });

	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

	scene = new Physijs.Scene();

	camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(60, 50, 60);
	camera.lookAt(scene.position);
	camera.zoom = 1;
	scene.add(camera);

	window.addEventListener( 'resize', function () {
	  camera.aspect = window.innerWidth / window.innerHeight;
	  camera.updateProjectionMatrix();
	  renderer.setSize( window.innerWidth, window.innerHeight );
	}, false);

	controls = new THREE.OrbitControls(camera, renderer.domElement);

  createDice();
  createFloor();
}

function createDice() {

	var diceSideMaterials = [];
	for (var i =1; i <= 6; i++) {

  	var mapFile = "face-" + i + ".png";
    var material = new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture(mapFile)
    });
    diceSideMaterials.push(material);
	}

  var box = new Physijs.BoxMesh(
    new THREE.BoxGeometry(10, 10, 10),
    Physijs.createMaterial(
      new THREE.MeshFaceMaterial(diceSideMaterials),
      0,	// friction
      0 	// restitution
    ),
    1 		// mass
  );
  box.position.x = (Math.random() * 15) - 7.5;
  box.position.y = 40;
  box.position.z = (Math.random() * 15) - 7.5;
            box.rotation.set(
                            Math.random() * Math.PI,
                            Math.random() * Math.PI,
                            Math.random() * Math.PI
                    );
  scene.add(box);

  var movement = new THREE.Vector3();
  function genVector() {
    return (Math.random() * 0.3) + 0.85;
  }

  movement.set(genVector(), genVector(), genVector());
  box.setAngularFactor(movement);
  box.setAngularVelocity(movement);
  box.setLinearFactor(movement);
  box.setLinearVelocity(movement);

  theDie = box;
}



function createFloor() {

	var floorColors = [
		0xff0000,
		0xff0000,
		0xaa0000,
		0xaa0000,
		0xff0000,
		0xff0000
	];

	var floorSideMaterials = [];
	for (var i = 0; i < floorColors.length; i++) {
		var material = new THREE.MeshBasicMaterial({
			color: floorColors[i],
			transparent: true,
			opacity: 0.0,		// 0 is fully transparent
		});
		floorSideMaterials.push(material);
	}

	var floor = new Physijs.BoxMesh(
	  new THREE.BoxGeometry(50, 1, 50),
	  Physijs.createMaterial(
	    new THREE.MeshFaceMaterial(floorSideMaterials),
	    0, // friction
	    0 // restitution
	  ),
	  0 //mass
	);
	floor.position.y = -10;
	scene.add(floor);

	var test = new THREE.HemisphereLight( 0x0000ff, 0x00ff00, 0.6 );
	scene.add(test)

}

function render() {

	// Use this if we want lots of dice.
  // boxes.forEach(function(box) {
  //   if (box.position.y < -20) {
  //     scene.remove(box);
  //     boxes.splice(boxes.indexOf(box), 1);
  //   }
  // });

  scene.simulate();
  renderer.render(scene, camera);
  requestAnimationFrame(render);

  controls.update();
}

function main() {
	init();
	requestAnimationFrame(render);
}

window.addEventListener("load", main, false);

</script>
</body>
</html>

